# key_vault Django Application - LI Network Component
# ⭐ CRITICAL FOR LAWFUL INTERCEPT (LI) ⭐
#
# Stores encrypted E2EE recovery keys for Matrix end-to-end encryption
# Enables lawful intercept to recover encrypted message history
#
# LOCATION: This service runs in the LI network (per CLAUDE.md requirements)
#
# ACCESS MODEL:
# - Synapse main (main network): Can STORE recovery keys (when users set up E2EE)
# - LI admin (LI network): Can RETRIEVE recovery keys (for lawful intercept workflow)
# - All other access: BLOCKED by NetworkPolicy
#
# DATABASE: SQLite (local file storage)
# - Low I/O requirements (only stores recovery keys)
# - Simple deployment (no external database dependency)
# - Data persisted on PVC
#
# IMPORTANT: You MUST provide a pre-built Django application image that includes:
# - Django project structure with key_vault app
# - Models for RecoveryKey storage
# - API endpoints for store_key and retrieve_key
# - All Python dependencies installed
# Replace CHANGEME_KEY_VAULT_IMAGE with your actual image URL
#
# SECURITY:
# - Located in LI network (isolated from main users)
# - Synapse main has specific NetworkPolicy access for storing keys
# - LI admin can retrieve keys from within LI network
# - RSA 2048-bit encryption for recovery keys
# - Private key stored securely, needed to decrypt recovery keys

---
# Secret for key_vault application
apiVersion: v1
kind: Secret
metadata:
  name: key-vault-secrets
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    matrix.instance: li
type: Opaque
stringData:
  # Django secret key
  # Generate using: python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'
  DJANGO_SECRET_KEY: "CHANGEME_DJANGO_SECRET_KEY_GENERATE_SECURE_RANDOM_STRING"

  # API key for Synapse main to access key_vault (for storing keys)
  # MUST match KEY_VAULT_API_KEY in main-instance/01-synapse/secrets.yaml
  API_KEY: "CHANGEME_SECURE_KEY_VAULT_API_KEY"

  # RSA 2048-bit private key for encrypting/decrypting recovery keys
  # Generate using: openssl genrsa -out private.pem 2048
  # Extract public key: openssl rsa -in private.pem -pubout -out public.pem
  #
  # IMPORTANT:
  # - Synapse main uses the PUBLIC key to encrypt recovery keys before storing
  # - LI admin uses the PRIVATE key to decrypt recovery keys for intercept
  # - Keep the private key secure - it enables access to all E2EE messages
  RSA_PRIVATE_KEY: |
    -----BEGIN RSA PRIVATE KEY-----
    CHANGEME_GENERATE_RSA_2048_BIT_PRIVATE_KEY
    Use: openssl genrsa -out private.pem 2048
    Then paste the content here
    -----END RSA PRIVATE KEY-----

---
# ConfigMap for key_vault configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: key-vault-config
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    matrix.instance: li
data:
  # Django settings - configured for SQLite database
  settings.py: |
    import os
    from pathlib import Path

    # Build paths
    BASE_DIR = Path(__file__).resolve().parent.parent

    # Security
    SECRET_KEY = os.environ['DJANGO_SECRET_KEY']
    DEBUG = False
    # Restrict to Kubernetes service names used by Synapse to access key_vault
    # NetworkPolicy provides additional layer of protection (only Synapse main can access)
    ALLOWED_HOSTS = [
        'key-vault',                                    # Short service name
        'key-vault.matrix',                             # Namespace-qualified
        'key-vault.matrix.svc',                         # Fully qualified (short)
        'key-vault.matrix.svc.cluster.local',           # Fully qualified
        'localhost',                                    # Health checks
    ]

    # Applications
    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'rest_framework',
        'secret',  # Key storage app (matches key_vault repo structure: secret/views.py)
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'key_vault.urls'

    # Database - SQLite (simple, low overhead, suitable for recovery key storage)
    # Data volume is low (one key per user), no need for PostgreSQL
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': '/data/key_vault.db',
            # SQLite optimizations for concurrent access
            'OPTIONS': {
                'timeout': 20,  # Wait up to 20 seconds for locks
            },
        }
    }

    # Logging
    LOGGING = {
        'version': 1,
        'disable_existing_loggers': False,
        'formatters': {
            'verbose': {
                'format': '{levelname} {asctime} {module} {message}',
                'style': '{',
            },
        },
        'handlers': {
            'console': {
                'class': 'logging.StreamHandler',
                'formatter': 'verbose',
            },
        },
        'root': {
            'handlers': ['console'],
            'level': 'INFO',
        },
        'loggers': {
            'recovery_keys': {
                'handlers': ['console'],
                'level': 'INFO',
                'propagate': False,
            },
        },
    }

    # REST Framework (API configuration)
    REST_FRAMEWORK = {
        'DEFAULT_AUTHENTICATION_CLASSES': [
            'rest_framework.authentication.TokenAuthentication',
        ],
        'DEFAULT_PERMISSION_CLASSES': [
            'rest_framework.permissions.IsAuthenticated',
        ],
    }

    # Encryption settings
    RSA_PRIVATE_KEY_PATH = '/secrets/rsa-private-key.pem'

    # Static files (for admin interface if needed)
    STATIC_URL = '/static/'
    STATIC_ROOT = '/tmp/static'

---
# PersistentVolumeClaim for SQLite database
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: key-vault-data
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    matrix.instance: li
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: standard  # Adjust to your cluster's storage class
  resources:
    requests:
      # Small storage - recovery keys are ~1KB each
      # 1Gi supports millions of keys with room for growth
      storage: 1Gi

---
# key_vault StatefulSet (for stable storage identity)
# Using StatefulSet instead of Deployment for SQLite data persistence
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: key-vault
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    app.kubernetes.io/version: "1.0.0"
    matrix.instance: li
spec:
  serviceName: key-vault
  replicas: 1  # Single replica (LI doesn't need HA per CLAUDE.md)

  selector:
    matchLabels:
      app.kubernetes.io/name: key-vault
      app.kubernetes.io/component: recovery-key-storage

  template:
    metadata:
      labels:
        app.kubernetes.io/name: key-vault
        app.kubernetes.io/component: recovery-key-storage
        app.kubernetes.io/version: "1.0.0"
        matrix.instance: li
      annotations:
        prometheus.io/scrape: "false"  # No Prometheus metrics (security consideration)

    spec:
      # Security context
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault

      # Schedule on LI server nodes
      # Adjust the label to match your LI node labels
      nodeSelector:
        node-role.kubernetes.io/li: "true"

      # Tolerate LI node taints if any
      tolerations:
        - key: "dedicated"
          operator: "Equal"
          value: "li"
          effect: "NoSchedule"

      # Init container for database migrations
      initContainers:
        - name: run-migrations
          # Use the same key-vault image for migrations
          # IMPORTANT: Replace with your actual key-vault image URL
          image: CHANGEME_KEY_VAULT_IMAGE:latest
          imagePullPolicy: IfNotPresent
          command:
            - python
            - manage.py
            - migrate
            - --noinput
          env:
            - name: DJANGO_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: key-vault-secrets
                  key: DJANGO_SECRET_KEY
          volumeMounts:
            - name: config
              mountPath: /app/key_vault/settings.py
              subPath: settings.py
              readOnly: true
            - name: data
              mountPath: /data
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "250m"
          securityContext:
            allowPrivilegeEscalation: false
            runAsNonRoot: true
            runAsUser: 1000
            capabilities:
              drop:
                - ALL

      containers:
        - name: key-vault
          # Configurable image URL - replace with actual key-vault image
          # IMPORTANT: You must provide a pre-built key-vault Django application image
          image: CHANGEME_KEY_VAULT_IMAGE:latest
          imagePullPolicy: IfNotPresent

          ports:
            - name: http
              containerPort: 8000
              protocol: TCP

          env:
            - name: DJANGO_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: key-vault-secrets
                  key: DJANGO_SECRET_KEY
            - name: API_KEY
              valueFrom:
                secretKeyRef:
                  name: key-vault-secrets
                  key: API_KEY

          volumeMounts:
            - name: config
              mountPath: /app/key_vault/settings.py
              subPath: settings.py
              readOnly: true
            - name: secrets
              mountPath: /secrets
              readOnly: true
            - name: data
              mountPath: /data
            - name: tmp
              mountPath: /tmp

          # Resource limits (reduced - SQLite is lightweight)
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "250m"

          # Liveness probe - TCP socket check (Django app responds on port 8000)
          # NOTE: If your key_vault image has a /health endpoint, you can use httpGet instead
          livenessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 30
            timeoutSeconds: 5
            failureThreshold: 3

          # Readiness probe - TCP socket check
          readinessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 2

          # Startup probe - TCP socket check
          startupProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 20

          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            capabilities:
              drop:
                - ALL

      volumes:
        - name: config
          configMap:
            name: key-vault-config
        - name: secrets
          secret:
            secretName: key-vault-secrets
            items:
              - key: RSA_PRIVATE_KEY
                path: rsa-private-key.pem
                mode: 0400
        - name: data
          persistentVolumeClaim:
            claimName: key-vault-data
        - name: tmp
          emptyDir: {}

---
# key_vault Service
apiVersion: v1
kind: Service
metadata:
  name: key-vault
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    matrix.instance: li
  annotations:
    description: |
      key_vault service in LI network.
      Access controlled by NetworkPolicy:
      - Synapse main (main network): Can STORE keys
      - LI admin (LI network): Can RETRIEVE keys
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
  ports:
    - name: http
      port: 8000
      targetPort: 8000
      protocol: TCP

---
# key_vault Ingress - For LI admin access to Django admin panel
# IMPORTANT: This Ingress is only accessible from the LI network
# The keyvault domain should resolve to the LI Ingress IP
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: key-vault-ingress
  namespace: matrix
  labels:
    app.kubernetes.io/name: key-vault
    app.kubernetes.io/component: recovery-key-storage
    matrix.instance: li
  annotations:
    # TLS configuration - use your cert-manager issuer
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    # Security headers
    nginx.ingress.kubernetes.io/proxy-body-size: "1m"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
spec:
  ingressClassName: nginx
  tls:
    - hosts:
        # CHANGEME: Replace with your key_vault domain
        - keyvault.example.com
      secretName: key-vault-tls
  rules:
    # CHANGEME: Replace with your key_vault domain
    - host: keyvault.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: key-vault
                port:
                  number: 8000
