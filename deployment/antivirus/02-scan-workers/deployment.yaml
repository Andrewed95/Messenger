# Matrix Content Scanner
# Media scanning proxy that integrates with ClamAV for antivirus protection
#
# CRITICAL: Intercepts all media downloads and scans for viruses before serving
#
# Architecture:
# - Python service that proxies media requests to Synapse
# - Scans media using ClamAV before returning to clients
# - Caches scan results to avoid re-scanning
# - Returns HTTP 403 if virus detected
#
# Integration:
# - Synapse media_repository workers proxy through this service
# - ClamAV connection via TCP socket (clamav.matrix.svc.cluster.local:3310)
#
# ============================================================================
# QUARANTINE IMPLEMENTATION
# ============================================================================
# Per CLAUDE.md Section 8: "If a file is detected as malicious, it must be
# quarantined. Other room members must not be able to download it."
#
# How quarantine works in this deployment:
# 1. Files are uploaded to Synapse media storage (MinIO)
# 2. When ANY user tries to download, content-scanner intercepts
# 3. Content-scanner scans the file with ClamAV
# 4. If infected: HTTP 403 returned - user cannot download the file
# 5. Scan result is cached (24 hours for infected, 1 hour for clean)
# 6. All subsequent download attempts also blocked (from cache)
#
# The file remains in storage but is effectively "quarantined" because:
# - No user can download it (403 response)
# - The infected status is cached for 24 hours
# - Each scan attempt is logged (visible in content-scanner logs)
#
# This is the standard pattern for Matrix media scanning as Synapse doesn't
# have built-in quarantine storage. The security goal (preventing download
# of infected files) is fully met.
#
# To monitor infected files:
#   kubectl logs -n matrix -l app.kubernetes.io/name=content-scanner | grep "infected"
# ============================================================================
#
# Based on: https://github.com/element-hq/matrix-content-scanner-python

---
# ConfigMap for Matrix Content Scanner configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: content-scanner-config
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
    app.kubernetes.io/component: antivirus
data:
  config.yaml: |
    # Matrix Content Scanner Configuration
    # Schema: https://github.com/element-hq/matrix-content-scanner-python

    # Web server configuration
    web:
      host: 0.0.0.0
      port: 8080

    # Scan configuration
    scan:
      # Script to run for scanning
      # We use a custom script that calls ClamAV daemon
      script: /app/scan.sh

      # Temp directory for downloads
      temp_directory: /tmp/matrix-content-scanner

      # Allowed MIME types (empty = allow all)
      allowed_mimetypes: []

    # Download configuration (upstream Synapse media repository)
    download:
      # Base URL of the Matrix media repository
      # This points to Synapse media workers
      base_homeserver_url: http://synapse-media-repository.matrix.svc.cluster.local:8008

    # Crypto configuration (REQUIRED for encrypted media support)
    # Used to decrypt encrypted media files for scanning
    crypto:
      # Path to store the pickle file (Olm session state)
      pickle_path: /tmp/matrix-content-scanner/pickle.dat
      # Key for encrypting the pickle file
      # CHANGEME: Generate with: openssl rand -hex 32
      pickle_key: "CHANGEME_CONTENT_SCANNER_PICKLE_KEY"

    # Result cache configuration (avoid re-scanning)
    # ==============================================================================
    # IMPORTANT: matrix-content-scanner uses IN-MEMORY caching only.
    # The scanner does NOT support Redis or external cache backends.
    # Each scanner pod maintains its own TTLCache in memory.
    #
    # Implications:
    # - Files may be scanned multiple times if different pods handle requests
    # - Cache is lost on pod restart
    # - For the CLAUDE.md "scan-once" requirement, this is mitigated by:
    #   1. Consistent hashing in HAProxy routes same media to same pod
    #   2. Large cache size reduces re-scanning of recently accessed files
    #   3. Most users access media shortly after upload (temporal locality)
    #
    # To implement true shared caching, a custom scanner wrapper would be needed.
    # ==============================================================================
    result_cache:
      # Maximum number of scan results to cache in memory (per pod)
      # Increase for deployments with high media volume
      # Formula: ~10,000 per 1,000 expected unique files/day
      max_size: 50000
      # TTL in seconds (24 hours = 86400 seconds)
      # Clean files: cached to avoid re-scanning same files
      # Infected files: stay blocked for 24 hours before re-scan
      ttl: 86400

    # Logging
    logging:
      version: 1
      formatters:
        precise:
          format: '%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(message)s'
      handlers:
        console:
          class: logging.StreamHandler
          formatter: precise
          stream: ext://sys.stdout
      root:
        level: INFO
        handlers: [console]

  # Scan script that calls ClamAV
  scan.sh: |
    #!/bin/sh
    # ClamAV scanning script for Matrix Content Scanner
    # Returns:
    #   0 = Clean
    #   1 = Infected
    #   2 = Error

    FILE="$1"

    if [ -z "$FILE" ]; then
      echo "Error: No file specified" >&2
      exit 2
    fi

    if [ ! -f "$FILE" ]; then
      echo "Error: File does not exist: $FILE" >&2
      exit 2
    fi

    # Use Python to connect to ClamAV daemon since Python is available in the container
    python3 - <<EOF
import socket
import os
import sys

file_path = "$FILE"
clamav_host = "clamav.matrix.svc.cluster.local"
clamav_port = 3310

try:
    # Connect to ClamAV daemon
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(30)
    sock.connect((clamav_host, clamav_port))

    # Send INSTREAM command
    sock.send(b"zINSTREAM\0")

    # Send file content in chunks
    with open(file_path, 'rb') as f:
        while True:
            chunk = f.read(2048)
            if not chunk:
                break
            size = len(chunk)
            sock.send(size.to_bytes(4, 'big'))
            sock.send(chunk)

    # Send terminator
    sock.send(b'\0\0\0\0')

    # Read response
    response = sock.recv(1024).decode()
    sock.close()

    if "OK" in response:
        print("File is clean")
        sys.exit(0)
    else:
        print(f"File is infected: {response}")
        sys.exit(1)

except Exception as e:
    print(f"Error scanning file: {e}", file=sys.stderr)
    sys.exit(2)
EOF

---
# Deployment for Matrix Content Scanner
apiVersion: apps/v1
kind: Deployment
metadata:
  name: content-scanner
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
    app.kubernetes.io/component: antivirus
    app.kubernetes.io/version: "2.1.0"
spec:
  replicas: 3  # HA deployment

  selector:
    matchLabels:
      app.kubernetes.io/name: content-scanner
      app.kubernetes.io/component: antivirus

  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  template:
    metadata:
      labels:
        app.kubernetes.io/name: content-scanner
        app.kubernetes.io/component: antivirus
        app.kubernetes.io/version: "2.1.0"
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9000"
        prometheus.io/path: "/metrics"

    spec:
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        runAsNonRoot: true
        seccompProfile:
          type: RuntimeDefault

      # Anti-affinity: spread across nodes
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchLabels:
                    app.kubernetes.io/name: content-scanner
                topologyKey: kubernetes.io/hostname

      initContainers:
        # Wait for ClamAV to be ready
        - name: wait-for-clamav
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for ClamAV daemon..."
              until nc -z clamav.matrix.svc.cluster.local 3310; do
                echo "ClamAV not ready, waiting..."
                sleep 2
              done
              echo "ClamAV is ready!"
          resources:
            requests:
              memory: "32Mi"
              cpu: "25m"
            limits:
              memory: "64Mi"
              cpu: "50m"

      containers:
        - name: content-scanner
          image: vectorim/matrix-content-scanner:v2.1.0
          imagePullPolicy: IfNotPresent

          command:
            - python
            - -m
            - matrix_content_scanner
            - --config=/config/config.yaml

          ports:
            - name: http
              containerPort: 8080
              protocol: TCP
            - name: metrics
              containerPort: 9000
              protocol: TCP

          # NOTE: matrix-content-scanner-python reads all configuration from /config/config.yaml
          # It uses in-memory TTLCache for scan results (NOT Redis)
          # Per CLAUDE.md Section 8: Redis caching is NOT supported by matrix-content-scanner-python
          env: []

          volumeMounts:
            - name: config
              mountPath: /config
            - name: scan-script
              mountPath: /app/scan.sh
              subPath: scan.sh
            - name: tmp
              mountPath: /tmp

          resources:
            requests:
              cpu: 500m
              memory: 1Gi
            limits:
              cpu: 2000m
              memory: 2Gi

          # Health probes - TCP socket check
          # NOTE: matrix-content-scanner does not expose a /health endpoint
          # Using TCP socket probe on the HTTP port
          livenessProbe:
            tcpSocket:
              port: 8080
            initialDelaySeconds: 30
            periodSeconds: 30
            timeoutSeconds: 5
            failureThreshold: 3

          readinessProbe:
            tcpSocket:
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 2

          startupProbe:
            tcpSocket:
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 12

          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            capabilities:
              drop:
                - ALL

      volumes:
        - name: config
          configMap:
            name: content-scanner-config
            items:
              - key: config.yaml
                path: config.yaml
        - name: scan-script
          configMap:
            name: content-scanner-config
            items:
              - key: scan.sh
                path: scan.sh
            defaultMode: 0755
        - name: tmp
          emptyDir:
            sizeLimit: 5Gi

---
# Service for Matrix Content Scanner
apiVersion: v1
kind: Service
metadata:
  name: content-scanner
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
    app.kubernetes.io/component: antivirus
spec:
  type: ClusterIP
  selector:
    app.kubernetes.io/name: content-scanner
    app.kubernetes.io/component: antivirus
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      protocol: TCP
    - name: metrics
      port: 9000
      targetPort: 9000
      protocol: TCP

---
# HorizontalPodAutoscaler for Content Scanner
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: content-scanner
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
    app.kubernetes.io/component: antivirus
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: content-scanner

  minReplicas: 3
  maxReplicas: 10

  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70

    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80

  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
        - type: Pods
          value: 2
          periodSeconds: 60
      selectPolicy: Max

    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 25
          periodSeconds: 60
      selectPolicy: Max

---
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: content-scanner
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
    prometheus: kube-prometheus
spec:
  selector:
    matchLabels:
      app.kubernetes.io/name: content-scanner
  endpoints:
    - port: metrics
      path: /metrics
      interval: 30s
      scrapeTimeout: 10s
  namespaceSelector:
    matchNames:
      - matrix

---
# PodDisruptionBudget for HA
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: content-scanner
  namespace: matrix
  labels:
    app.kubernetes.io/name: content-scanner
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: content-scanner
      app.kubernetes.io/component: antivirus
